{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE RankNTypes #-}

module Raft.Types where

import Protolude

import Data.Sequence (Seq(Empty, (:<|)), (<|))
import qualified Data.Sequence as Seq
import Numeric.Natural (Natural)

type NodeId = ByteString
type NodeIds = Set NodeId

newtype Term = Term Natural
  deriving (Show, Eq, Ord, Enum)

term0 :: Term
term0 = Term 0

incrTerm :: Term -> Term
incrTerm = succ

newtype Index = Index Natural
  deriving (Show, Eq, Ord, Enum, Num, Integral, Real)

index0 :: Index
index0 = Index 0

incrIndex :: Index -> Index
incrIndex = succ

decrIndex :: Index -> Index
decrIndex (Index 0) = index0
decrIndex i = pred i

data NodeConfig = NodeConfig
  { configNodeId :: NodeId
  , configNodeIds :: NodeIds
  , configElectionTimeout :: Int
  , configHeartbeatTimeout :: Int
  } deriving (Show)

-- | An entry in the replicated log
data Entry v = Entry
  { entryIndex :: Index
    -- ^ index of entry in log
  , entryTerm :: Term
    -- ^ term when entry was received by leader
  , entryValue :: v
    -- ^ command to update state machine
  , entryClientId :: ClientId
  } deriving (Show)

data AppendEntryError
  = UnexpectedLogIndex Index Index
  deriving (Show)

type Entries v = Seq (Entry v)

-- | The replicated log of entries on each node
newtype Log v = Log { unLog :: Entries v } deriving Show

-- | Append a log entry to the log. Checks if the log is the correct index
appendLogEntry :: Log v -> Entry v -> Either AppendEntryError (Log v)
appendLogEntry (Log logEntries) newEntry =
    case logEntries of
      Empty
        | newEntryIndex == 0 -> Right newLog
        | otherwise -> Left (UnexpectedLogIndex newEntryIndex 0)
      entry :<| entries
        | newEntryIndex == entryIndex entry + 1 -> Right newLog
        | otherwise -> Left (UnexpectedLogIndex newEntryIndex (entryIndex entry + 1))
  where
    newEntryIndex = entryIndex newEntry
    newLog = Log (newEntry <| logEntries)

-- | Append a sequence of log entries to the log. The log entries must be in
-- descending order with respect to the log entry indices.
appendLogEntries :: Log v -> Seq (Entry v) -> Either AppendEntryError (Log v)
appendLogEntries = foldrM (flip appendLogEntry)

lookupLogEntry :: Index -> Log v -> Maybe (Entry v)
lookupLogEntry idx (Log log) =
  Seq.lookup (fromIntegral idx) log

lastLogEntry :: Log v -> Maybe (Entry v)
lastLogEntry (Log entries) = lastEntry entries

lastEntry :: Seq (Entry v) -> Maybe (Entry v)
lastEntry Empty = Nothing
lastEntry (e :<| _) = Just e

-- | Get the last log entry index
lastLogEntryIndex :: Log v -> Index
lastLogEntryIndex log =
  case lastLogEntry log of
    Nothing -> index0
    Just entry -> entryIndex entry

-- | Get the last log entry index and term
lastLogEntryIndexAndTerm :: Log v -> (Index, Term)
lastLogEntryIndexAndTerm log =
  case lastLogEntry log of
    -- TODO: Is term0 the default term when there are no logs?
    -- If we store a log for each new election, then the default term can be 0
    Nothing -> (index0, term0)
    Just entry -> (entryIndex entry, entryTerm entry)

takeLogEntriesUntil :: Log v -> Index -> Entries v
takeLogEntriesUntil (Log log) idx =
  Seq.takeWhileL ((<=) idx . entryIndex) log

dropLogEntriesUntil :: Log v -> Index -> Log v
dropLogEntriesUntil (Log log) idx =
  Log (Seq.dropWhileL ((<=) idx . entryIndex) log)

-- | State saved to disk before performing actions generated by event handling.
--
-- TODO This value is passed to the TransitionM monad such that the currentTerm
-- and votedFor fields can be accessed; however, the entire log is not needed.
-- For most event handlers, only the last log entry is needed; unfortunately,
-- the AppendEntries handler needs yet another log entry: the log entry at the
-- index specified by 'prevLogIndex' field of 'AppendEntries'.
--
-- Soon, we should make another datatype that captures this necessity, reading
-- the last log entry and log entry at `prevLogIndex` if the event is an
-- 'AppendEntries' RPC message sent from a leader.
data PersistentState v = PersistentState
  { psCurrentTerm :: Term
    -- ^ Last term server has seen
  , psVotedFor :: Maybe NodeId
    -- ^ candidate id that received vote in current term
  , psLog :: Log v
    -- ^ log entries; each entry contains command for state machine
  } deriving (Show)

--------------------------------------------------------------------------------
-- Events
--------------------------------------------------------------------------------

newtype ClientId = ClientId NodeId
  deriving (Show, Eq)

newtype LeaderId = LeaderId { unLeaderId :: NodeId }
  deriving (Show, Eq)

data Timeout
  = ElectionTimeout
    -- ^ Timeout in which a follower will become candidate
  | HeartbeatTimeout
    -- ^ Timeout in which a leader will send AppendEntries RPC to all followers
  deriving (Show)

data ClientReq v
  = ClientReq ClientId v
  deriving (Show)

data Event v
  = Message (Message v)
  | ClientRequest (ClientReq v)
  | Timeout Timeout
  deriving (Show)

--------------------------------------------------------------------------------
-- Actions (TODO move to src/Raft/Action.hs)
--------------------------------------------------------------------------------

data CurrentLeader
  = CurrentLeader LeaderId
  | NoLeader
  deriving (Show, Eq)

data Action v
  = SendMessage NodeId (Message v)
    -- ^ Send a message to a specific node id
  | SendMessages (Map NodeId (Message v))
    -- ^ Send a unique message to specific nodes in parallel
  | Broadcast NodeIds (Message v)
    -- ^ Broadcast the same message to all nodes
  | ApplyCommittedEntry (Entry v)
    -- ^ Apply a replicated log entry to state machine
  | ResetTimeoutTimer Timeout Int
    -- ^ Reset a timeout timer
  | RedirectClient ClientId CurrentLeader
    -- ^ Redirect a client to the current leader
  | RespondToClient ClientId
    -- ^ Respond to client after successful command application
  deriving (Show)

--------------------------------------------------------------------------------
-- Node States
--------------------------------------------------------------------------------

data FollowerState = FollowerState
  { fsCurrentLeader :: CurrentLeader
    -- ^ The id of the current leader
  , fsCommitIndex :: Index
    -- ^ index of highest log entry known to be committed
  , fsLastApplied :: Index
    -- ^ index of highest log entry applied to state machine
  } deriving (Show)

data CandidateState = CandidateState
  { csCommitIndex :: Index
    -- ^ index of highest log entry known to be committed
  , csLastApplied :: Index
    -- ^ index of highest log entry applied to state machine
  , csVotes :: NodeIds
  } deriving (Show)

data LeaderState = LeaderState
  { lsCommitIndex :: Index
    -- ^ index of highest log entry known to be committed
  , lsLastApplied :: Index
    -- ^ index of highest log entry applied to state machine
  , lsNextIndex :: Map NodeId Index
    -- ^ for each server, index of the next log entry to send to that server
  , lsMatchIndex :: Map NodeId Index
    -- ^ for each server, index of highest log entry known to be replicated on server
  } deriving (Show)

--------------------------------------------------------------------------------
-- RPCs
--------------------------------------------------------------------------------

data Message v = RPC
  { sender :: NodeId
  , rpc :: RPC v
  } deriving (Show)

data RPC v
  = AppendEntriesRPC (AppendEntries v)
  | AppendEntriesResponseRPC AppendEntriesResponse
  | RequestVoteRPC RequestVote
  | RequestVoteResponseRPC RequestVoteResponse
  deriving (Show)

class RPCType a v where
  toRPC :: a -> RPC v

instance RPCType (AppendEntries v) v where
  toRPC = AppendEntriesRPC

instance RPCType AppendEntriesResponse v where
  toRPC = AppendEntriesResponseRPC

instance RPCType RequestVote v where
  toRPC = RequestVoteRPC

instance RPCType RequestVoteResponse v where
  toRPC = RequestVoteResponseRPC

rpcTerm :: RPC v -> Term
rpcTerm = \case
  AppendEntriesRPC ae -> aeTerm ae
  AppendEntriesResponseRPC aer -> aerTerm aer
  RequestVoteRPC rv -> rvTerm rv
  RequestVoteResponseRPC rvr -> rvrTerm rvr

data AppendEntries v = AppendEntries
  { aeTerm :: Term
    -- ^ leader's term
  , aeLeaderId :: LeaderId
    -- ^ so follower can redirect clients
  , aePrevLogIndex :: Index
    -- ^ index of log entry immediately preceding new ones
  , aePrevLogTerm :: Term
    -- ^ term of aePrevLogIndex entry
  , aeEntries :: Seq (Entry v)
    -- ^ log entries to store (empty for heartbeat)
  , aeLeaderCommit :: Index
    -- ^ leader's commit index
  } deriving (Show)

data AppendEntriesResponse = AppendEntriesResponse
  { aerTerm :: Term
    -- ^ current term for leader to update itself
  , aerSuccess :: Bool
    -- ^ true if follower contained entry matching aePrevLogIndex and aePrevLogTerm
  } deriving (Show)

data RequestVote = RequestVote
  { rvTerm :: Term
    -- ^ candidates term
  , rvCandidateId :: NodeId
    -- ^ candidate requesting vote
  , rvLastLogIndex :: Index
    -- ^ index of candidate's last log entry
  , rvLastLogTerm :: Term
    -- ^ term of candidate's last log entry
  } deriving (Show)

data RequestVoteResponse = RequestVoteResponse
  { rvrTerm :: Term
    -- ^ current term for candidate to update itself
  , rvrVoteGranted :: Bool
    -- ^ true means candidate recieved vote
  } deriving (Show)
